---
title: 沒有多重繼承
slug: >-
  conflicting/Web/JavaScript/Guide/Details_of_the_Object_Model_60d6c39d4282c67c117db9fdaf83be08
translation_of: Web/JavaScript/Guide/Details_of_the_Object_Model
translation_of_original: >-
  Web/JavaScript/Guide/Obsolete_Pages/Property_Inheritance_Revisited/No_Multiple_Inheritance
original_slug: Web/JavaScript/Obsolete_Pages/Obsolete_Pages/Obsolete_Pages/再談屬性的繼承/沒有多重繼承
---
<h3 id="沒有多重繼承" name="沒有多重繼承">沒有多重繼承</h3>
<p>部分物件導向語言允許多重繼承。也就是說，物件可以從互不相關的親物件繼承屬性和值。不過 JavaScript 並不支援多重繼承。</p>
<p>屬性值的繼承發生在執行時期，由 JavaScript 搜尋物件的原型鏈以找出繼承值。由於物件只有單一的已連結原型，因此 JavaScript 並不能從多於一個以上的原型鏈中動態的繼承。</p>
<p>在 JavaScript 中，建構子函數的內部可以有很多個其他的建構子函數的呼叫。如此可提供多重繼承的假象。例如，思考下面的語句︰</p>
<pre>function Hobbyist (hobby) {
   this.hobby = hobby || "scuba";
}

function Engineer (name, projs, mach, hobby) {
   this.base1 = WorkerBee;
   this.base1(name, "engineering", projs);
   this.base2 = Hobbyist;
   this.base2(hobby);
   this.machine = mach || "";
}
Engineer.prototype = new WorkerBee;

dennis = new Engineer("Doe, Dennis", ["collabra"], "hugo")
</pre>
<p>接著假定 <code>WorkerBee</code> 的定義使用的是本章先前的內容。在這個情況下，<code>dennis</code> 物件就有了這些屬性︰</p>
<pre>dennis.name == "Doe, Dennis"
dennis.dept == "engineering"
dennis.projects == ["collabra"]
dennis.machine == "hugo"
dennis.hobby == "scuba"
</pre>
<p>所以 <code>dennis</code> 從 <code>Hobbyist</code> 建構子中得到了 <code>hobby</code> 的屬性。然而，假定你稍後把新的屬性加入到 <code>Hobbyist</code> 建構子的原型︰</p>
<pre>Hobbyist.prototype.equipment = ["mask", "fins", "regulator", "bcd"]
</pre>
<p><code>dennis</code> 物件並未繼承到這個新的屬性。</p>
<div class="noinclude">
<p>{{ PreviousNext("Core_JavaScript_1.5_教學:再談屬性的繼承:建構子中的全域資訊", "Core_JavaScript_1.5_教學:LiveConnect_概要") }}</p>
</div>
